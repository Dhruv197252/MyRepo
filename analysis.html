<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Static Sidebar with Navbar</title>
    <!-- Tailwind CSS CDN -->
    <link
      href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css"
      rel="stylesheet"
    />
    <style>
      /* Custom style to transition the sidebar */
      .sidebar-hidden {
        transform: translateX(-100%);
        transition: transform 0.3s ease-in-out;
      }

      .sidebar-visible {
        transform: translateX(0);
        transition: transform 0.3s ease-in-out;
      }
    </style>
  </head>

  <body class="bg-gray-900 text-gray-300">
    <!-- Navbar -->
    <nav class="bg-gray-900 text-white p-8">
      <div class="container mx-auto flex items-center justify-between">
        <div class="flex items-baseline">
          <!-- Menu Icon -->
          <button
            id="menu-btn"
            class="text-white text-2xl mr-4 focus:outline-none"
          >
            ☰
          </button>
          <a href="#" class="text-2xl font-bold text-white">Merge Sort</a>
        </div>
        <div class="flex items-center space-x-16">
          <a href="#" class="text-gray-300 hover:text-blue-400">Home</a>
          <a href="#" class="text-gray-300 hover:text-blue-400">Collaborator</a>
          <a href="#" class="text-gray-300 hover:text-blue-400">Contact</a>
        </div>
      </div>
    </nav>

    <!-- Main Content Wrapper -->
    <div class="flex">
      <!-- Sidebar -->
      <aside
        id="sidebar"
        class="w-64 bg-gray-900 shadow-md h-screen sticky top-0 p-4 sidebar-visible"
      >
        <h2 class="text-xl font-semibold mb-4 text-white">Algorithm</h2>
        <ul>
          <li>
            <a
              href="#"
              class="block py-2 px-3 text-gray-300 hover:bg-gray-700 rounded"
              >Pretest</a
            >
          </li>
          <li>
            <a
              href="#"
              class="block py-2 px-3 text-gray-300 hover:bg-gray-700 rounded"
              >Introduction</a
            >
          </li>
          <li>
            <a
              href="#analysis"
              class="block py-2 px-3 text-gray-300 hover:bg-gray-700 rounded"
              >Analysis</a
            >
          </li>
          <li>
            <a
              href="#"
              class="block py-2 px-3 text-gray-300 hover:bg-gray-700 rounded"
              >Quiz</a
            >
          </li>
          <li>
            <a
              href="#"
              class="block py-2 px-3 text-gray-300 hover:bg-gray-700 rounded"
              >Simulation</a
            >
          </li>
          <li>
            <a
              href="#"
              class="block py-2 px-3 text-gray-300 hover:bg-gray-700 rounded"
              >Posttest</a
            >
          </li>
        </ul>
      </aside>

      <!-- Main Content -->
      <main class="flex-1 p-8 text-gray-300">
        <h2 class="text-3xl font-bold mb-6">Analysis</h2>
        <p class="text-lg mb-6">
          To understand the concept of Time and Space Complexity, let's imagine
          you're organizing a deck of cards.
        </p>

        <h3 class="text-2xl font-semibold mb-6">
          Time Complexity (How long it takes)
        </h3>
        <h4 class="text-xl mb-4">1.Breaking the Deck in Half:</h4>
        <p class="mb-4">
          Imagine you keep splitting the deck of cards into two halves. First,
          you split it into 2 piles, then each of those into 2 more piles, and
          so on.<br />
          For example, if you have 8 cards, after 3 splits, you'll have 8 single
          cards. The number of splits you make is similar to the time
          complexity. For `n` cards, it takes about `log(n)` splits. The base of
          log is generally taken as 2 in Computer Science.
        </p>
        <h4 class="text-xl mb-4">2.Putting the Deck Back Together:</h4>
        <p class="mb-4">
          Now, you start putting the cards back together, two at a time, and
          sorting them as you go. This step takes some time because you’re
          checking which card is smaller or bigger.<br />
          For each level of merging (putting the cards together), you look at
          all the cards once. Since you do this for every level, and there are
          `log(n)` levels, it ends up being `n * log(n)`.
        </p>
        <p class="mb-10">
          So, the <strong>time complexity</strong> of Merge Sort is `O(n *
          log(n))`. This means the time it takes grows in a way that depends on
          both the number of cards (n) and how many times you can split them
          (log(n)).
        </p>

        <h3 class="text-2xl font-semibold mb-6">
          Space Complexity (How much space it needs)
        </h3>
        <p class="mb-4">
          When you split the deck, you need extra tables to hold the smaller
          piles of cards before you put them back together. These extra tables
          represent the <strong>extra space</strong> you need.<br />
          Since you're creating new piles for each split, the amount of space
          you need depends on the number of cards. If you have `n` cards, you'll
          need extra space to hold those `n` cards temporarily.
        </p>
        <p class="mb-6">
          So, the <strong>space complexity</strong> is `O(n)`, which means you
          need space proportional to the number of cards you have.
        </p>

        <h3 class="text-2xl font-semibold mb-4">
          Best, Average, and Worst Case Scenarios
        </h3>
        <p class="mb-4">
          Let's stick with the card sorting example to explain the best,
          average, and worst cases for Merge Sort.
        </p>

        <h4 class="text-xl font-semibold mb-2">
          Best Case Scenario (Everything is Perfect!)
        </h4>
        <p class="mb-4">
          <strong>Imagine:</strong> You have a deck of cards that's already
          perfectly sorted.<br />
          <strong>What Happens:</strong> Even though the cards are already in
          order, Merge Sort still goes through its usual steps. It will split
          the cards into smaller piles and then merge them back together.<br />
          <strong>Time Taken:</strong> Even though the cards are sorted, Merge
          Sort doesn't skip any steps. So, it still takes `O(n * log(n))` time.
          There’s no special shortcut here.
        </p>

        <h4 class="text-xl font-semibold mb-2">
          Average Case Scenario (Normal Situation)
        </h4>
        <p class="mb-4">
          <strong>Imagine:</strong> You have a deck of cards that are in a
          random order, like how you'd normally shuffle them.<br />
          <strong>What Happens:</strong> Merge Sort will split the cards, sort
          each pair, and then merge them back together.<br />
          <strong>Time Taken:</strong> On average, it takes `O(n * log(n))` time
          to sort the cards. This is because the process of splitting and
          merging is the same whether the cards are randomly ordered or in a
          mixed state.
        </p>

        <h4 class="text-xl font-semibold mb-2">
          Worst Case Scenario (A Messy Deck)
        </h4>
        <p class="mb-6">
          <strong>Imagine:</strong> You have a deck of cards that's completely
          out of order—like the worst shuffle ever.<br />
          <strong>What Happens:</strong> Merge Sort still splits and merges the
          cards in the same way, step by step.<br />
          <strong>Time Taken:</strong> Even in the worst possible situation,
          Merge Sort takes `O(n * log(n))` time. The algorithm doesn't get
          slower, no matter how messed up the deck is.
        </p>

        <h3 class="text-2xl font-semibold mb-4">Summary</h3>
        <p class="mb-4">
          <strong>Best Case:</strong> Even if the deck is perfectly sorted,
          Merge Sort still takes `O(n * log(n))`.<br />
          <strong>Average Case:</strong> For a normally shuffled deck, it also
          takes `O(n * log(n))`.<br />
          <strong>Worst Case:</strong> Even with a completely messed-up deck,
          Merge Sort takes `O(n * log(n))`.
        </p>
        <p class="mb-6">
          In all cases, Merge Sort is consistently efficient, with the same time
          complexity no matter what.
        </p>
      </main>
    </div>
  </body>
</html>
